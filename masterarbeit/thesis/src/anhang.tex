\chapter{Anhang}

\section*{Algorithmen für Geobuckets}
\begin{algorithm}
\SetAlgoLined
\SetKwInOut{Input}{Eingabe}
\SetKwInOut{Output}{Ausgabe}
\Input{Polynome $p, q$ mit Monomen $m_{p_i}$ und $m_{q_j}$, wobei $i = \#p$ und $j = \#q$}
\Output{Polynom $p'$ mit geordneten Monomen}
$n \gets \#p, k\gets \#q$ \\
$buckets$ mit Platz geom. wachsender Größe anlegen: $\{2k, 4k, ..., 2^{\lceil log_2(n)\rceil -1 }k\}$\\
$i\gets 0 $\\
\While(\Comment*[f]{Bis jedes Monom aus $q$ betrachtet wurde}){$i < n$}{
    $p' \gets m_{p_i} \cdot q$\\
    \uIf{$i < (n-1)$}{
        $p' \gets p' + m_{p_{i+1}} \cdot q$\\
    }
    $i\gets i+2$\\
   $j\gets 0 $\\ 
    \While(\Comment*[f]{Sammle alle Buckets ein und speichere in $p'$}){$buckets[j]\neq \emptyset$}{
        $p' \gets p' + buckets[j]$\Comment*{Polynome gleicher Größe werden addiert}
        $buckets[j] \gets [\ ]$\\
        $j\gets j+1 $\\ 
    }
    \uIf(\Comment*[f]{Wurde $q$ nicht komplett betrachtet}){$i < n$}{
        $buckets[j] \gets p'$\Comment*{Speichere $p'$ im aktuell leeren Bucket $j$}
        $p' \gets 0$ \Comment*{Leere $p'$ für eine neue Iteration vorbereiten}
    }
    
}
\ForEach(\Comment*[f]{Merge aller Buckets ins Polynom}){$bucket \in buckets$}{
    $p' \gets p' + bucket$\Comment*{vom kleinsten zum größten}
}


\Return $p'$

 \caption{Polynommultipliaktion mit Geobuckets}
 \label{algo:mult}
\end{algorithm}


\begin{algorithm}[H]
\SetAlgoLined
\label{algo:add}
\SetKwInOut{Input}{Eingabe}
\SetKwInOut{Output}{Ausgabe}
\Input{Polynome $p, q$ mit Monomen $m_{p_i}$ und $m_{q_j}$, wobei $i = \#p$ und $j = \#q$}
\Output{Polynom $p'$ mit geordneten Monomen}
$i \gets 0, j \gets 0$ \\
\While(\Comment*[f]{Solange ein Polynom nicht komplett betrachtet wurde}){$i < \#p$ \textbf{and} $j  < \#q$} {
    \uIf{$m_{p_i} \succ m_{q_j}$}{
        $p' \gets p' + m_{p_i}$\\
        $i \gets i+1 $\\
    }
    \uElseIf{$m_{q_j} \succ m_{p_i}$}{
        $p' \gets p' + m_{q_j}$\\
        $j \gets j+1 $\\
    }
    \uElse(\Comment*[f]{Beide Monome haben dieselben Variablen}){
        $p' \gets p' + (m_{q_j} + m_{p_i})$\\
        $i \gets i+1; j \gets j +1 $\\
    }
}
\If{$i < \#p$ \textbf{or} $j  < \#q$}{
Füge den Rest zu $p$ hinzu
}

\Return $p$

 \caption{Addition zweier geordneter Polynome}
\end{algorithm}


\Abbildungps{tbh}{.9}{img/7iter_w_sweep.pdf}{fig:7iter}{H\e non-Abbildung: Mehrere Iterationen mit Farbkodierung}{Mehrere Iterationen mit Farbkodierung}

\section*{Details der Implementierung}

\begin{lstlisting}[language=JSON, caption=Bespielkonfiguration,captionpos=b, label=list:config]
 [
  {
    "comment": "Error 100",
    "rel": 1,
    "linear": 0,
    "keep": 2,
    "error_in_lambda": true,
    "strategy": "SQUARE_ONLY",
    "iter": 1000,
    "prec": 50,
    "error": 1000,
    "decimals": 20,
    "sweep_to": 2,
    "micro_thresh": 1,
    "macro_thresh": 1,
    "a": 1.4,
    "b": 0.3,
    "support_space": [
      {
        "point": false,
        "mid": "0",
        "rad": "e"
      },
      {
        "point": false,
        "mid": "0",
        "rad": "e"
      }
    ],
    "x": {
      "kernel": {
        "point": true,
        "mid": "1",
        "rad": "0"
      },
      "monomials": [
        {
          "point": true,
          "mid": "1",
          "rad": "0",
          "lambdas": [{
            "exp": 1,
            "index": 0
          }]
        }
      ]
    },
    "y": {
      "kernel": {
        "point": true,
        "mid": "0.1",
        "rad": "0"
      },
      "monomials": [
        {
          "point": true,
          "mid": "1",
          "rad": "0",
          "lambdas": [{
            "exp": 1,
            "index": 1
          }]
        }
      ]
    }
  }
]
\end{lstlisting}
