

\section{Übung}
\subsection*{Übung 3:}
\paragraph{1)} Durch entfernen von Kanten soll der Graph zerlegt werden. (Unions in umgekehrter Reihenfolge)

\paragraph{2)}
Zu zeigen:
$$ a(z,n) \leq \lfloor\frac{4m}{n}\rfloor\ für\  z=\alpha (m,n) $$
Definition von a und $ \alpha $ 
$$a(z,n) = min \{j|A(z,j) > logn \} $$
$$\alpha(m,n)=min\{i|A(i, \lfloor\frac{4m}{n}\rfloor) > logn\}$$
Behauptung:
$$a(\alpha(m,n), n) \leq \lfloor\frac{4m}{n}\rfloor$$
Beweis: indirekt. Annahme:
$$a(\alpha(m,n), n) > \lfloor\frac{4m}{n}\rfloor$$
$$\Rightarrow A(\alpha(m,n),\lfloor\frac{4m}{n}\rfloor) \leq logn $$
Widerspruch zur Definition von $ \alpha $ , denn
$$A(\alpha(m,n),\lfloor\frac{4m}{n}\rfloor) > logn $$

\paragraph{3.a)} Union-Split-Find. (van Emde-Boas aht Datenstruktur mit log log n für Union-Split-Find. ) Gegeben ist eine Array
\begin{itemize}
    \item Split(i): Markiere i
    \item Find(x): Finde nächste Markierung
    \item Union(x): Lösche Markierung x
\end{itemize}
Balancierter (blatt-orientierter) Baum zur Speicherung der markierten Elemente. Einfügen der markierten Elemente als Blätte rdes Baums
\begin{itemize}
    \item Split = Insert
    \item Union = Delete
    \item Find = Locate
\end{itemize}
Platz = \#Intervalle, Zeit O(logn)
\paragraph{3.b)} 
\begin{itemize}
    \item Insert = Split
    \item Delete = Union
    \item FindMin = Find(1)
\end{itemize}

\subsection*{Übung 4:}
\paragraph{1)} Rekursive Funktion zum Aufbau eines RST \\
A[1,...,n] von Schlüsseln. P[1,...,n] Prioritäten

\begin{algorithm}
    \For{$1\gets 0 $ \KwTo{n}}{
        $P[i]\gets random()$
    }
\end{algorithm}

Rekursice Funktion RST(A,P,l,r) baut einen RST für A[l,...,r] und liefert Pointer auf die Wurzel.

\begin{verbatim}
class rst_node {
    key
    prio
    left,right: rst_node
}
\end{verbatim}

\begin{algorithm}
    \SetKwProg{Def}{def}{:}{end}
    \Def{RST(A,P,l,r)}{
        \uIf{ $l>r$} {
            \Return null;
        }
        $i \gets max[P,l,r]$ \;
        $q \gets$ new rstnode \;
        $q.key \gets$ A[i] \;
        $q.prio \gets$ P[i] \;
        $q.left \gets$ RST(A,P,l,i-1) \;
        $q.right \gets$ RST(A,P,i+1,r) \;
        \Return q;
    }
\end{algorithm}




\paragraph{2)}
Spiel B symmetrisch zu Spiel A.

\paragraph{3)} Implementiertung von Hashing mit Verkettung. Idee:
Tafelgröße s beliebig. Hashfunktion $ h(x) = x \cdot mod s $\\
\begin{algorithm}[H]
\SetKwProg{Def}{def}{:}{end}
\Def{Insert(x)}{
    
}
\Def{Lookup(x)}{
    
}
\Def{Delete(x)}{
    
}
\end{algorithm}

\paragraph{4)} Belegungsfaktor $ \beta = \frac{n}{m} $ m = Tafelgröße. Bei Hashing mit Verkettung ist $ \beta $ = erwartete Länge einer Liste. Laufzeit für eine Operation $ O(1+\beta) = O(1) \text{ für } \frac{1}{2} \leq \beta \leq 2$ 
\subparagraph{Rehash} Die Tabelle muss in eine größere Liste kopiert werden \\
\begin{algorithm}[H]
\SetKwProg{Def}{def}{:}{end}
\Def{Insert(x)}{
    ... \;
    $n\gets n+1$ \;
    \uIf{$\frac{n}{m} > 2$} {
        $m_0 \gets m$ \;
        $m \gets 2m$ \;
        $T' \gets new\ int[m]$
    }
    Kopiere alte Tabelle in neue \;
}
\Def{Delete(x)}{
    $n\gets n-1$
    \uIf{$\frac{n}{m} < \frac{1}{2}$}{
        ...\;
        $ m\gets \frac{m}{2}$\;
        Kopiere alte Tabelle in neue \;
    }

}

\end{algorithm}

\subsection{Übung 5}

\subsection{Übung 6}

\subsection{Übung 7}

\subsection{Übung 8}
\paragraph{2)} Belegungsfaktor = $ \beta = \frac{n}{k} $. Ziel ist $ \frac{1}{2} \leq \beta \leq 2 $. Erwartete Laufzeit pro Operation $ O(1 + \beta) $. Rehashing: Test nach Inerst/Delete. Wenn $ \beta $ außerhalb des Zielintervalls, Rehash mit $ k \gets n $. \\
Potentialmethode: $ pot: D \rightarrow \mathbb{R}^+_0 $. Folge von Insert, Rehash mit pot = 2 $ \cdot $ Anzahl der Markierten
\begin{enumerate}
    \item Rehash löscht alle Markierungen
    \item Insert markiert neues Elemenent
\end{enumerate} 
pot = 2 $ \cdot $ Anzahl der Eingefügten + 1 $ \cdot $ (Anzahl der Gelöschten seit dem letzten Rehash) \\

\begin{itemize}
    \item $ T_{amontisiert} (INSERT) = O(1+\beta) + 2$  
    \item $ T_{amontisiert} (INSERT) = O(1+\beta) + 1$
    \item $ T_{amontisiert} (INSERT)$
    \begin{itemize}
        \item Verdopplung: $O(n) - 2\cdot neue$
        \item Halbierung: $-n$
    \end{itemize}
\end{itemize}

\paragraph{3)} Darstellungen von planaren Einbettungen:
\begin{itemize}
    \item Face Zyklen. Auflistung der Knoten eines Faces 
    \item Nachbarn jedes Knotens. Sortierung der Adjazenslisten
\end{itemize}
Implementierung als doppelt verkettete Listen.


\subsection{Übung 9}
\paragraph{1)} G planarer Graph mit $ n \geq 3 $. Sei d der maximale Grad eines Knotens und $ n_i = $ Anzahl von Knoten vom Grade i. Dann gilt 

$$ 5n_1 + 4n_2 + 3n_3 + 2n_4 + n_5  \geq n_7 + 2n_8 + ... + (d-6) n_d + 12$$
$$ 0 \geq  5n_1 - 4n_2 - 3n_3 - 2n_4 - n_5 + n_7 + 2n_8 + ... + (d-6) n_d + 12$$
$$ \sum_{i = 1}^{d} (i-6) \cdot n_i +12 \leq 0 $$
$$ \underbrace{\sum_{i = 1}^{d} i \cdot n_i}_{2m} - \underbrace{\sum_{i = 1}^{d} 6 n_i}_{6n} +12 \leq 0 $$
$$ m -3n + 6 \leq 0$$
$$ m  \leq 3n - 6 $$

\paragraph{2)} Für jede Kante e=(x,y) gilt: $ G|e $ enthält eine Unterteilung des $ K_5 $ oder $ K_{3,3} $, dann enthält auch G eine solche Unterteilung. Sei H die Unterteilung des $ K_5 $ bzw $ K_{3,3} $ in $ G|e $.\\
\underline{Fall 1:} $ z \in H $ und $ deg_H(z)=0 $, dann existiert H auch in G. \\
\underline{Fall 2:} $ z \in H$ mögliche Grade  $ deg_H(z) \in \{2, 3, 4 \} $ \\
\underline{Fall 2.1:} $ deg_H(z) = 2 $ (z liegt auf einer Kante) G $ \Rightarrow $ G enthält H der gleichen Art \\
\underline{Fall 2.2:} $ deg_H(z) = 3 $ z ist Ende eines $ K_{3,3} $
\underline{Fall 2.3:} $ deg_H(z) = 4 $ z ist Ende eines $ K_{5} $
\begin{enumerate}
    \item Hat x eine Kante in H, so ist x ein Subdivision-Knoten (symmetrisch für y)
    \item Hat x 2 Kanten in H, so bilden x und y einen $ K_{3,3} $
\end{enumerate}



\section{Allgemeines}
\subsection{Einschub: Erwartungswerte}
Situation: n Ereignisse, die mit einer gweissen Wahrscheinlichkeit prob(i) auftreten. Jedes Ereignis besitzt einen Wert val(i). 
$$E(val) = \sum_{i_1}^{n} prob(i)\cdot val(i) $$
Spezialfall: Gleichverteilung: $ prob(i)=\frac{1}{n} für\ 1\leq i \leq n $. Dann gilt:
$$ E(val)= \frac{1}{n} \sum_{i=1}^{n}val(i) = Mittelwert $$

\subsection{Integrierende Reihe}
$ x \leq 1 $
$$ \sum_{i=0}^\infty x^i \cdot i = \frac{x}{(1-x)^2}$$



