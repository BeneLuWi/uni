\documentclass[ngerman]{scrartcl}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{algorithm2e}
\usepackage{hyperref}


\title{Algorithmen und Datenstrukturen (Master) \\ WiSe 19/20}
\author{Benedikt Lüken-Winkels}
\begin{document}

\maketitle
\tableofcontents
\newpage


\subsection*{Wörterbuchproblem}
Menge S mit n Schlüssln aus einem Universum U.
Operationen: INSERT (darauf achten, dass die Balance nicht verloren geht), DELETE, LOOKUP (Im Baum runterlaufen, bis das Element gefunden wurde)
\paragraph{Situationen}
\begin{enumerate}
    \item U linear geordnet, also existiert ein $ \leq $-Test $ \Rightarrow $ Suchbäume
    \item U ist ein Intervall $ \{0,..., N-1\} $ der gesamten Zahlen $ \Rightarrow $ Hashing
\end{enumerate}
\subsubsection*{\underline{zu 1:}}

\paragraph{Randomisierte Suchbäume}
Idee: Benutze Zufallszahlen zur Balancierung eines binären Suchbaums

\paragraph{Binärer Suchbaum (Knoten-Orientiert)}
Schlüssel werden in den n Knoten eines binären Baums gespeichert, sodass im linken Unterbaum des Knotens mit Schlüssel x alle Schlüssel $ < x $ \textbf{und} im rechten Unterbaum alle $ > x $. Balanciert $ \Rightarrow Höhe(T)\leq logn$.  Degeneriert $ \Rightarrow Höhe(T) = O(n)$

\subsubsection*{Definition: Randomized Search Tree (RST)}
Sei $ S=\{x_1,...,x_n\} $ eine Menge von n Schlüsseln. Jedem $ x_i $ wird eine zusätzlich eine Zufallszahl (auch Priorität genannt) $ prio(x_i) $ zugeordnet. $ prio(x_i) $ sind gleichverteilte reelle Zufallszahlen $ \in [0,1] $ (Implementierung wären int-Zahlen, zB 32-bit). \\
Ein RST für S ist eine binärer Suchbaum für die Paare $ (x_i, prio(x_i), 1 \leq i \leq n $, sodass
\begin{enumerate}
    \item normaler Knoten-orientierter Suchbaum für die Schlüssel $ x_i,...,x_n $
    \item Maximumsheap bzgl der Prioritäten. dh $ prio(v) \geq prio(u) $, falls v Parent. ((u,v) sind Knoten in einem Baum). $ \Rightarrow $ Wurzel enthält maximale Priorität.
\end{enumerate}
\textbf{Existenz} durch Algorithmus zum Aufbau (rekursiv).
\begin{itemize}
    \item Wurzel einthält $ (x_i, p_i) $ mit $ p_i = prio(x_i) $ maximal
    \item Linker Unterbaum: RST für $ \{(x_i, p_i)| x_j < x_i \} $
    \item Rechter Unterbaum: RST für $ \{(x_k, p_k)| x_k > x_i \} $
\end{itemize}
Beispiel: $ S=\{1,...,10\} $
\begin{itemize}
    \item Schreibe Tabelle mit Prioriäten und Werten.
    \item Teile die Tabelle beim Maximum und schreibe es in die Wurzel. Wiederhole, bis alle Elemente geschrieben.
\end{itemize}
$ \Rightarrow $ Wenn sich die Prioritäten genauso oder umgekehrt, wie die Schlüssel verhalten, erhält man einen degenrierten Baum. (bzgl $ \leq $). zB $ prio(x_i) = x_i $. Dieser Fall ist sehr unwahrscheinlich, wenn sich bei der Priorität um gleichverteilte Zufallszahlen handelt. 

\subsubsection*{Operationen}

\begin{itemize}
    \item Lookup(x): normale suche in binärem Baum. Kosten $ O(Höhe(T)) $
    \item Insert(x): Füge einen neuen Knoten v als Blatt $ (x, prio(x)) $ gemäß des Schlüssels in den binären Baum ein, wobei $ prio(x) $ neue Zufallszahl (kann die Prio-Ordnung zerstören). Dann: Rotiere v nach oben, bis die Heap-Eigenschaft gilt, also $ prio(v) \leq prio(parent(v)) $. Kosten: O(\#Rotationen) = O(Höhe(T)). Alternativ: normales einfügen in binären Baum in absteigender Reihenfolge der Prioritäten.
    \item DELETE(x): Sei v der knoten mit Schlüssel x (v = Lookup(x)). Kosten: O(\#Rotationen) = O(1 + |L| + |R|)
    \begin{enumerate}
        \item Rotiere v nach unten, bis v ein Blatt ist. R = linkes Rückgrat des rechten Unterbaums von v. L = rechtes Rückgrat des linken Unterbaums. 
        \item Entferne das Blatt.
    \end{enumerate}
    \item Split(y) $ \rightarrow $ $ S_1=\{x\in S | x \leq y\}, S_2=\{x\in S | x \geq y\} $ (Teile den Baum, indem y mit maximaler Priorität zur Wurzel rotiert wird)
    \begin{enumerate}
        \item Insert($ y + \epsilon $) mit Priorität $ \infty $
        \item Entferne die Wurzel 
    \end{enumerate}
    \item Join$ (T_1, T_2 )$: $ S\leftarrow S_1 \cup S_2 $. $T_1$ RST für $S_1$ und $T_2$ RST für $S_2$
    \begin{enumerate}
        \item Konstruiere T (Füge y zwischen Max($S_1$) und Min($S_2$) ein. Voraussetzung: Max($S_1$) < Min($S_2$)
        \item Lösche die Wurzel (Durch runterrotieren des eingefügten Knotens y)
    \end{enumerate}
\end{itemize}

\subsubsection*{Analyse des RST}
Wir analysieren die erwarteten Kosten einer Delete-Operation (Insert $ \rightarrow $ umgekehrtes Delete). Seit T ein RST für die Menge $ \{x_1,...,x_n\}mit x_1 < x_2 < ... < x_n $ der durch Inserts aufgebaut wurde. Bertrachte die Operation Delete($ x_k $) für eine $ k, 1\leq k\leq n $. Für einen Knoten $ x_k $ im Baum T mit Suchpfad $ P_k $, $ L_k $ rechtes Rückgrad von $ T_l $ und $ R_k $ linkes Rückgrad von $ T_r $.  Kosten $ O(|P_k| + |L_k| + |R_k|) $. Wir schätzen die Erwartungswerte 

\subsubsection*{Lemma 1:}
\begin{itemize}
    \item a) E$ (|P_k|) $ = $ H_k + H_{n-k+1} - 1$ $$k-te\ Harmonische Zahl=H_k = \sum_{i_1}^{k}\frac{1}{i}\ H_k \leq ln(x)+1$$
    \item b) E$ (|L_k|) $ = $ 1-\frac{1}{k} $
    \item c) E$ (|R_k|) $ = $ 1-\frac{1}{n-k+1} $
\end{itemize}
\paragraph{Beweis} Betrachte eine Permutation $ \pi:[1..n] \rightarrow [1..n] $ (bijektive Abbildung), die die Schlüssel absteigend nach ihren Prio Werten sortiert. Dann gilt: 
\begin{enumerate}
    \item Jede Permutation $ \pi $ ist gleichwahrscheinlich (Wahrscheinlichkeit $ \frac{1}{n!} $), da die Prioritäten gleichverteilte Zufallszahlen sind.
    \item Man erhält den selben binären Baum durh einfügen der Schlüssel in einen unbalancierten Baum in der Reihenfolge, die $ \pi $ angibt. $ \rightarrow $ gleiches Vehalten, wie ein zufälliger binärer Baum.
    \item Baum wächst nur an den Blättern.
\end{enumerate}
Trick: arbeite ab jetzt mit zufälliger Permutation statt den Prioritäten. $ \rightarrow $ normaler Binärbaum mit zufälliger Einfügereihenfolge.
\paragraph{Teil a) des Lemmas} $P_k $ ist Suchpfad für Knoten $x_k $. Seien $ P'_k $ und $ P''_k $ Teilfolgen von $ P_k $ mit: $ \forall v \in P'_k, key(v)\leq x_k $ und $ \forall u \in P''_k, key(u)\geq x_k $. Beobachtungen:
\begin{enumerate}
    \item $ |P_k| = |P'_k| + |P''_k| - 1 $ ($ x_k $ in beiden Teilfolgen)
    \item $ P'_k = $ Menge der knoten v mit:
    \begin{itemize}
        \item Wenn v eingefügt wird, gilt key(v) ist maximal mit key(v)$ \leq x_k $
    \end{itemize}
    \item $ P''_k = $ Menge der knoten u mit:
    \begin{itemize}
        \item Wenn u eingefügt wird, gilt key(u) ist minimal mit key(u)$ \geq x_k $
    \end{itemize}
\end{enumerate}
Wir zeigen
\begin{enumerate}
    \item E($ |P'_k| $) = $ H_k $
    \item E($ |P''_k| $) = $ H_{n-k+1} $
\end{enumerate}
\underline{zu 1)} K mögliche Kandidaten für $ P'_k \{x_1,...,x_k\}$. Spiel: Ziehe zufällig Schlüssel aus $\{x_1,...,x_k\}$. E($ |P'_k| $) = Erwartungswert, wie of ein Kandidat gezogen wird, der $ \geq $ als alle vorher gezogenen ist. $ A^k = E(|P'_k|)$ (Spiel A)
$$A^k = \sum_{i=1}^k \frac{1}{k} \cdot (1 + A^{k-i})$$










\section{Übung}
\subsection*{Übung 3:}
\paragraph{1)} Durch entfernen von Kanten soll der Graph zerlegt werden. (Unions in umgekehrter Reihenfolge)

\paragraph{2)}
Zu zeigen:
$$ a(z,n) \leq \lfloor\frac{4m}{n}\rfloor\ für\  z=\alpha (m,n) $$
Definition von a und $ \alpha $ 
$$a(z,n) = min \{j|A(z,j) > logn \} $$
$$\alpha(m,n)=min\{i|A(i, \lfloor\frac{4m}{n}\rfloor) > logn\}$$
Behauptung:
$$a(\alpha(m,n), n) \leq \lfloor\frac{4m}{n}\rfloor$$
Beweis: indirekt. Annahme:
$$a(\alpha(m,n), n) > \lfloor\frac{4m}{n}\rfloor$$
$$\Rightarrow A(\alpha(m,n),\lfloor\frac{4m}{n}\rfloor) \leq logn $$
Widerspruch zur Definition von $ \alpha $ , denn
$$A(\alpha(m,n),\lfloor\frac{4m}{n}\rfloor) > logn $$

\paragraph{3.a)} Union-Split-Find. (van Emde-Boas aht Datenstruktur mit log log n für Union-Split-Find. ) Gegeben ist eine Array
\begin{itemize}
    \item Split(i): Markiere i
    \item Find(x): Finde nächste Markierung
    \item Union(x): Lösche Markierung x
\end{itemize}
Balancierter (blatt-orientierter) Baum zur Speicherung der markierten Elemente. Einfügen der markierten Elemente als Blätte rdes Baums
\begin{itemize}
    \item Split = Insert
    \item Union = Delete
    \item Find = Locate
\end{itemize}
Platz = \#Intervalle, Zeit O(logn)
\paragraph{3.b)} 
\begin{itemize}
    \item Insert = Split
    \item Delete = Union
    \item FindMin = Find(1)
\end{itemize}

\section{Allgemeines}
\subsection{Einschub: Erwartungswerte}
Situation: n Ereignisse, die mit einer gweissen Wahrscheinlichkeit prob(i) auftreten. Jedes Ereignis besitzt einen Wert val(i). 
$$E(val) = \sum_{i_1}^{n} prob(i)\cdot val(i) $$
Spezialfall: Gleichverteilung: $ prob(i)=\frac{1}{n} für\ 1\leq i \leq n $. Dann gilt:
$$ E(val)= \frac{1}{n} \sum_{i=1}^{n}val(i) = Mittelwert $$






\end{document}










